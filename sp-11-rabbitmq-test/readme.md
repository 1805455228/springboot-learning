
## 场景一：异步记录用户操作日志

对于企业级应用系统或者微服务应用中，我们经常需要追溯跟踪记录用户的操作日志，而这部分的业务在某种程度上是不应该跟主业务模块耦合在一起的，故而我们需要将其单独抽出并以异步的方式与主模块进行异步通信交互数据。

下面我们就用 RabbitMQ 的 DirectExchange+RoutingKey 消息模型也实现“用户登录成功记录日志”的场景。如前面所言，我们需要在脑海里回荡着几个要点：

消息模型：DirectExchange+RoutingKey 消息模型
消息：用户登录的实体信息，包括用户名，登录事件，来源的IP，所属日志模块等信息
发送接收：在登录的 Controller 中实现发送，在某个 listener 中实现接收并将监听消费到的消息入数据表；实时发送接收
首先我们需要在上面的 RabbitmqConfig 类中创建消息模型：包括 Queue、Exchange、RoutingKey 等的建立



## 场景二：异步发送邮件

发送邮件的场景，其实也是比较常见的，比如用户注册需要邮箱验证，用户异地登录发送邮件通知等等，在这里我以 RabbitMQ 实现异步发送邮件。实现的步骤跟场景一几乎一致！


## 秒杀系统，抢单

* 并发量配置与消息确认机制 实战背景

    - 对于消息模型中的 listener 而言，默认情况下是“单消费实例”的配置，即“一个 listener 对应一个消费者”，
    这种配置对于上面所讲的“异步记录用户操作日志”、“异步发送邮件”等并发量不高的场景下是适用的。但是在对于秒杀系统、
    商城抢单等场景下可能会显得很吃力！
    - 我们都知道，秒杀系统跟商城抢单均有一个共同的明显的特征，即在某个时刻会有成百上千万的请求到达我们的接口，
    即瞬间这股巨大的流量将涌入我们的系统

* 当到了“开始秒杀”、“开始抢单”的时刻，此时系统可能会出现这样的几种现象：

    - 应用系统配置承载不了这股瞬间流量，导致系统直接挂掉，即传说中的“宕机”现象；
    - 接口逻辑没有考虑并发情况，数据库读写锁发生冲突，导致最终处理结果跟理论上的结果数据不一致（如商品存库量只有 100，但是高并发情况下，实际表记录的抢到的用户记录数据量却远远大于 100）；
    - 应用占据服务器的资源直接飙高，如 CPU、内存、宽带等瞬间直接飙升，导致同库同表甚至可能同 host 的其他服务或者系统出现卡顿或者挂掉的现象；

* 常用解决方案

    - 我们会将处理抢单的整体业务逻辑独立、服务化并做集群部署；
    - 我们会将那股巨大的流量拒在系统的上层，即将其转移至 MQ 而不直接涌入我们的接口，从而减少数据库读写锁冲突的发生以及由于接口逻辑的复杂出现线程堵塞而导致应用占据服务器资源飙升；
    - 我们会将抢单业务所在系统的其他同数据源甚至同表的业务拆分独立出去服务化，并基于某种 RPC 协议走 HTTP 通信进行数据交互、服务通信等等；
    - 采用分布式锁解决同一时间同个手机号、同一时间同个 IP 刷单的现象；

