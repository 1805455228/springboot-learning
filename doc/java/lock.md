
# 锁的笔记


### 重量级锁


### synchronized 同步锁、重量级锁（一般情况下占用的操作系统的资源比较多） 性能上却不是最优的

* synchronized 加在成员方法上的；锁的是：代码块

* synchronized 加在静态成员方法上的；锁的是：整个类对象

* 耗费操作系统的资源比较多：阻塞，上下文的切换，线程调度




### cas 自旋锁、轻量级锁、无锁--原子性

* 无锁（在硬件上加锁--不在程序上加锁）

* aba问题 (两个线程同时拿到A；；线程2改C又改为A；线程1)

thread01 ---- A===改===B

thread02 ---- A===改===C===改===A

* cas的aba问题：对结果无影响

* 解决cas的aba问题：使用乐观锁方式加version

* 轻量级锁耗费操作系统资源少----但有个空转问题（所以并发量大的情况下--会造成很多线程在空转--造成CPU占用高）



### JDK的synchronized锁的升级策略


* 有些情况下轻量级锁性能比重量级锁差

* JDK1.6之后对synchronized锁的优化 （锁的升级）

为了换取性能，JVM在内置锁上做了非常多的优化，膨胀式的锁分配策略就是其一。
理解偏向锁、轻量级锁、重量级锁的要解决的基本问题，几种锁的分配和膨胀过程，有助于编写并优化基于锁的并发程序。

* 线程很多---采用重量级锁

  偏向锁（单线程）----轻量级锁（cas）（并发一般）-----重量级锁（并发大）

  - 偏向锁：（单线程）

    - 如果需要，使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。

  - 轻量级锁


  - 重量级锁



```
偏向锁、轻量级锁、重量级锁适用于不同的并发场景：

偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。
轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。
重量级锁：有实际竞争，且锁竞争时间长。

```




### 对象结构

* 对象头  (Mark Word是对象头的一部分，可以看出对象是否有锁以及锁的膨胀策略)

* 实例数据

* 对象对齐填充位


最近需求，打算再内存缓存数据，数据量130000万并且还会增加，了解这些数据占用空间的大小是很常见的监控需要。

常规方式，人工可以按照Java基础数据类型大小及内容大小估算出缓存对象的大概堆占用，但是麻烦还不准。

OpenJDK，提供了JOL包，可以帮我们在运行时计算某个对象的大小，是非常好的工具


```
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>put-the-version-here</version>
</dependency>

```

（1）查看对象内部信息： ClassLayout.parseInstance(obj).toPrintable()

（2）查看对象外部信息：包括引用的对象：GraphLayout.parseInstance(obj).toPrintable()

（3）查看对象占用空间总大小：GraphLayout.parseInstance(obj).totalSize()



### 分段cas  LongAdder










